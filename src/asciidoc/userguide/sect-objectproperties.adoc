
[[sect-objectproperties]]
== Java Object properties

////
- Random stuff that you may need when using Units and Quantitys as POJOs, but is not part of the API.

- Should be in the javadocs anyway, so not needed?

- Or break this up and put it where first relevant?
////

This section discusses properties of the UOM classes that are not specifically part of the API, but affect how you can use them.

=== Extendability

//  (check)

All Unit and Quantity classes are final.
They follow the Value-based Class pattern from https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/doc-files/ValueBased.html#Value-basedClasses

////
Value-based Classes
Some classes, such as java.util.Optional and java.time.LocalDateTime, are value-based. Instances of a value-based class:
are final and immutable (though may contain references to mutable objects);
have implementations of equals, hashCode, and toString which are computed solely from the instance's state and not from its identity or the state of any other object or variable;
make no use of identity-sensitive operations such as reference equality (==) between instances, identity hash code of instances, or synchronization on an instances's intrinsic lock;
are considered equal solely based on equals(), not based on reference equality (==);
do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of returned instances;
are freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior.
A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization, or any other identity-sensitive mechanism. Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided.
////

=== Thread safety

Quantity and Unit instances are immutable therefore unconditionally thread safe.

=== Identity, equality and equivalence

////
- Don't use ==

- Do use .equals(). Assume same units and same value?
Does this not imply comparing floating points? 
This is usually a bad thing?

- Equivalence definition and discussion from Gitter

- Compatibility
////

TBD

=== Ordering

// - Dont understand why Quantity doesn't implement comparable?

Quantites are not declared as comparable, but they seem to be anyway:

[source,java]
----
include::{basedir}/src/main/java/Examples.java[tag="collections"]
----

Sorting is by base value as you would hope.

If you want to make explicit comparisons, declare your variables as ++ComparableQuantity++:

[source,java]
----
include::{basedir}/src/main/java/Examples.java[tag="comparable"]
----

=== Serialisation

==== Using +java.io.Serializable+

Yes, with no restrictions.

==== Using text

Yes, with some caveats.

The text (`Quantity.toString()`) form is guaranteed to be convertible to and from the binary form without loss of precision.
That is:

[source,java]
----
include::{basedir}/src/main/java/Examples.java[tag="text"]
----

This is required by the JSR, so should be true for any other implementation as well.

If you have defined your own units, either convert the quantities to built-in units before export, or distribute your program as well, otherwise the recipient will not be able to parse the output.

If you are restricted to ASCII-only files (ie no Unicode), use the ASCII flavour of +SimpleQuantityFormat+ (How? show example)

==== Using JavaBeans XML

Not currently implemented.
See {issue}/264[issue #264] and {issue}/266[issue #266].


